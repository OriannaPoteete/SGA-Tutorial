---
title: "SGA Data Analysis Tutorial"
author: "OP & PC"
date: "5/5/22"
output:
  pdf_document: 
    latex_engine: xelatex
---


# Introduction

Welcome to the Serum Growth Assay Analysis Tutorial! In this tutorial, we will go through how to use RStudio to analyze data from a Serum Growth assay.

A Serum Growth Assay is one where your isolate is grown in media that is some percentage of serum. In this tutorial, we use a practice data set where isolates were grown in either 0% Serum (Limited Media only), 50% Serum (Limited Media + Serum), and 50% Heat-inactivated (HI) Serum (Limited Media + HI-Serum). The heat-inactivated serum was created by incubating serum at 56^o^C for 30 minutes.

Before you begin to use this tutorial, you will need to install some packages in order to perform the analysis. The accompanying README file will detail which packages and what you need to do to install them into RStudio.

# Setting Up the Knit options for RMarkdown

Before we begin the analysis using R, we need to set up the knit options. Knitting is how Rstudio will print an output file. In this tutorial, we will knit to pdf, so when you hit the knit button, which is found at the top of the RMarkdown pane (which should be at the top of this window pane), Rstudio will run all of the different code chunks and save the results in a PDF. The following code chunk will set up some options for knitting. Run this code chunk by hitting the play button at the top right corner of the chunk (next to the cog wheel).

```{r setup, include=TRUE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

Let's breakdown what this code chunk does:

* knitr::opts_chunk$set -- this is the function that will allow us to set some options for how RStudio will knit our RMarkdown.
* warning = FALSE -- This tells Rstudio that we don't want to see any warning in the pdf when we knit.
* message = FALSE -- This will prevent warning messages when knitting.
* echo = FALSE -- This is not in the above code chunk, but worth mentioning. This condition will prevent RStudio from printing out the code chunks when you knit. This is a nice option to make your pdf output a little more professional.

# Loading the Appropriate Libraries
This code chunk will load the necessary libraries need for our analysis. These libraries should already be installed, but if not, please see the README file on how to do it.

Every time you open a project in RStudio, you will need to run your library code chunk, or a lot of your code chunks will just return an error instead of the results you want. Go ahead and run this code chunk.
```{r load libraries}
library(dplyr)
library(ggplot2)
library(tinytex)
library(tidyverse)
library(readxl)
library(viridis)
library(ggpubr)
library(knitr)
library(kableExtra)
```

# Preparing Data for Analysis

## Importing Data from Excel

RStudio is a great tool for analyzing your data, but it is very tedious to input that data into a usable format in RStudio. We opted to using Excel to organize our data and import it into RStudio. Run the following code chunk and select the tutorial Excel file to import the data to RStudio.

```{r read file}
# raw_data <- read_excel(file.choose(), sheet = "Sheet1")
raw_data <- read_excel("C:/Users/kopot/Documents/SGA-Tutorial/SGA_Example_DataSet.xlsx", 
                       sheet = "Sheet1")
raw_data
```

* raw_data -- this is a name for a variable we chose to store our EXcel data. The "<-" says to store everything to the left of our variable name into that variable name. You can see what is in that variable by having a line that has just the variable name.
* read_excel <- This function is part of the readxl library and will read_excel in a RStudio friendly format.
    + file.choose() -- This will prompt a window that will let you choose an excel file for RStudio to load.
    + sheet -- This will tell the read_excel function which sheet in Excel contains the data you want to import into RStudio. The default is "Sheet1", so we'll leave it like this for now.

## Replacing Special Characters in Column Names

While RStudio is great for analyzing data, we have to format our data to use it in RStudio. RStudio does not like having special characters in the column names and will not perform analysis. First we will identify and remove special characters from the column names in our data set.

This code chunk will store our data set into a new variable. Whenever you are formatting your data, it is recommended to store your data into a new variable and use that to perform your formatting, so that you can go back if you make a mistake. Run the following code chunk to create a new data set that we will use.

```{r, New datset}
raw_data_colnames <- raw_data
```

The following code chunk identifies the special characters by their Unicode and replaces them with specified text. In the accompanying README file we will provide a list of what we believe the most common special characters are and their Unicode.

Here we use $\Delta$ as an example and provide "del" as a suggestion for replacing it. Run the following code chunk and we'll go over what we just ran.

```{r, Replacing Special Characters}
delta_replace <- gsub("\u0394", "del", colnames(raw_data_colnames))

colnames(raw_data_colnames) <- delta_replace

options(dplyr.width = Inf)

raw_data_colnames
```

* delta_replace <- Variable that we will store our replace function.
* gsub <- Creates a list with the special character replaced by the given text.
    + "\u0394" -- Unicode for the $\Delta$.
    + "del" -- Text that will be replacing $\Delta$.
    + colnames() -- This is a function that will call the column names for the dataframe. This is used to tell gsub where the special characters are to replace.
* options <- Changes with options for knitting the table.
    + dplyr.width = Inf -- Changes the width of the table to infinity so that the whole table fits on one page.
* raw_data_colnames <- This prints the changed data frame to see if we replaced $\Delta$ in our column names.


## Averaging Blank Measurements for Removing Background Noise

Now that we have formatted our data frame, we can begin the analysis.First, we need to subtract the background noise from our data.

For each time point, we took a blank measurement, which is a well that has the serum type but no cells. We use this to determine background noise. Since we took a blank measurement at each time point, we now need to average them. We can do this so long as all of the blank measurements are roughly similar looking (i.e. there are no outliers). Run the next code chunk to create a new variable that we will store the blank values in.

```{r, second New dataset}
raw_data_blank_mean <- raw_data_colnames
```

This next code chunk will perform what's called "piping", represented by %>%. Piping is a way for RStudio to say "and then" when running code chunks. Before, we wrote single lines of code and when we executed them, RStudio will just run that line and be done. With piping, we can run a line of code, take the results and automatically run them through another line of code. For more information on piping, please visit https://www.datacamp.com/tutorial/pipe-r-tutorial.

Run the following line of code to average your blank measurements and we'll explain what we just did.

```{r, Averaging Blanks}
raw_data_blank_mean <- raw_data_colnames %>%
  select(contains("Blank")) %>%
  colMeans(na.rm = TRUE) %>%
  round(3)
```

* select() <- Allows you to pick which columns to use from the data frame. You can also remove columns by typing a "-" symbol before the column name (see the next code chunk for an example).
    + contains("") -- This looks at the titles of the columns and selects the ones that have the inputted value/text within the quotations. Here we are just selecting each column that contains "Blank" in the names.
* colMeans() <- This calculates the means for each column.
    + na.rm = TRUE -- This tells the colMeans function to ignore the NA values in the data frame. Note: when you import data from excel, any blank cell will return a "NA".
* round() <- This tells the output of colMeans what decimal point to round to. Here, we tell it to round to 3 significant figures by inputting 3 as an argument.

## Removing Blank Measurement from Table

Now that we have our blanks values stored as a variable, we can remove them from our data frame. We'll also be removing the "Time" column to help us with formatting the data for graphing. Run the followign code chunk to do so.

```{r clean data}
raw_data_clean <- raw_data_colnames %>%
  select(-`0% (Blank)`, -`50% (Blank)`, -`HI-50% (Blank)`, -`Time`)
```

## Removing Background Noise

Here's where things get interesting. We now need to take our measurements and subtract the background noise to get the true measurement values. This is where things get a little complicated. Instead of writing many lines of code to do the subtractions, we can write a for loop to do the math automatically.

A for loop is a way to tell RStudio to iterate through our data, based on conditions we set, and perform an action. A for loop has a beginning and an end, and will never continue after it's ended. Run the following code chunk, then we'll break down all of the different parts.

```{r for loop}
for (a in 1:ncol(raw_data_clean)) {
 if (grepl(" 0%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[1])
 }
 if (grepl(" 50%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[2])
 }
 if (grepl("-50%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[3])
 }
}
```

* for(){} <- This codes a conditional statement where it will loop through the values specified in the parenthesis, running the code specified within the curly brackets. This will stop when it reaches the end (in this case, when it iterates through all of the columns in our data frame).
* if(){} <- this codes a Boolean (TRUE/FALSE) conditional statement, where if the conditional statement within the parenthesis is TRUE, then it will run the code in the curly brackets. If the conditional statement is FALSE, it will do nothing.
    + grepl() <- This looks for a specific inputted value and returns either TRUE or FALSE.
    + a -- This is a variable that the for loop needs in order to loop through our data set. This can really be anything, either a letter, or a word.
    + as.numeric() <- This makes sure inputted values are seen as numbers by RStudio, if they are not saved as such.

Another concept that we introduced here is an index. An index (represented by []) is a way to call specific positions within a list or table. Here, we use [ , a] to call the columns (syntax is [rows, columns]); we'll leave the row section blank so that only the columns are called. In the raw_data_blank_mean, since those values are in a list, we use [a number] to call the position of our blank values in that list; for instance, raw_data_blank_mean[1] is where the blank average for 0% Serum is located.

# Printing Our Data

We've now cleaned our data of background noise and now we need to format it for printing to a PDF. This first task will be formatting it to print to a table

``` {r replace}
raw_data_clean_t <- raw_data_clean

delta_replace <- gsub("del", "\u0394", colnames(raw_data_clean_t))

colnames(raw_data_clean_t) <- delta_replace

options(dplyr.width = Inf)
kable(raw_data_clean_t, caption = "Serum Growth Assay for eOP16", "latex", 
      booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down", "hold_position"))
```

* kable() <- displays a dataset in a table
    + caption = "" -- text which appears above the table?
    + booktabs = T -- changes the way LaTex formats and displays the table
    + kable_styling() -- allows for customization of the displayed table
    + latex_options = "" -- customizes the colors and structure of the table

## Transforming the Data

```{r time}
trans_data <- stack(raw_data_clean)
time_data <- raw_data_colnames %>%
  select(`Time`)
length <- length(raw_data_clean)
time_data <- cbind(rep(time_data$Time, as.numeric(length)))
trans_data <- cbind(trans_data, time_data)
colnames(trans_data) <- c("OD", "Sample", "Time")
```

* stack() <- stacks multiple columns into one column
* length() <- the amount of columns in the dataset
* cbind() <- combines data by columns
    + rep() -- the data that will be repeated a set number of times

## Graphing Cleaned Data

```{r plots}
od_600 = expression(paste(OD[600]))
zero_plot <- trans_data %>%
  filter(grepl(" 0%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "0% Serum", y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

fifty_plot <- trans_data %>%
  filter(grepl(" 50%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "50% Serum",  y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

hi_plot <- trans_data %>%
  filter(grepl("HI-50%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "HI-50% Serum", y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

figure_1 <- ggarrange(zero_plot, fifty_plot, hi_plot,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2, common.legend = TRUE,legend="bottom")
annotate_figure(figure_1, top = text_grob("Serum Growth Assay for eOP16", 
               color = "black", face = "bold", size = 14))
```

* expression() <- creates an object
    + paste() <- chains together vectors after converting them to characters
* filter() <- this selects which columns to analyze by given parameters
* ggplot() <- allows the data to be displayed within a plot
    + aes() -- this is what is used to choose which variables are displayed on different portions of the graph
    + y = "" -- variable displayed on the y-axis
    + x = "" -- variable displayed on the x-axis
    + color = "" -- variable displayed through the colors
* geom_point() -- this selects a scatterplot as the specific plot
* goem_line() -- this creates a line between point on the scatterplot
* labs() -- this labels various potions of the plot
    + title = "" -- labels the title
    + y = "" -- labels the y-axis
* theme() -- customizes non-data portion of the plot
    + plot.title = "" -- the title of the plot
    + element_text() -- tells it to look at the variable title and use that?
    + hjust = 0.5 -- changes the size of the 
    + legend.title = "" -- alters the legend title
    + element_blank() -- tells it to exclude the legend title
* scale_colour_manual() -- customizes the color types and scale of the colors
    + values = "" -- selects the colors based on their hex number
    + labels = "" -- labels the legend
* xlim() -- x axis limits
* ylim() -- y axis limits
* ggarrange() <- allows for multiple plots to be displayed at once together
    + labels = "" -- labels the various plots
    + ncol = "" -- how many plots are side by side
    + nrow = "" -- how many plots are up and down
    + common.legend = TRUE -- this allows for there to be a common legend, or if it was false than the graphs would have seperate legends
    + legend = "" -- location of the legend in relation to the placement of the graph
* annotate_figure() <- customizes the plot figure that was created
    + top = "" -- placement of the figure title
    + text_grob() -- the text that will show up as the figure title
    + color = "" -- changes the color of the text
    + face = "" -- changes the font (i.e. italics, bold, etc.)
    + size = "" -- size of text

