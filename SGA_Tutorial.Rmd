---
title: "SGA Data Analysis Tutorial"
author: "OP & PC"
date: "5/5/22"
output:
  pdf_document: 
    latex_engine: xelatex
---


# Introduction

Welcome to the Serum Growth Assay Analysis Tutorial! In this tutorial, we will go through how to use RStudio to analyze data from a Serum Growth assay.

A Serum Growth Assay is one where your isolate is grown in media that is some percentage of serum. In this tutorial, we use a practice data set where isolates were grown in either 0% Serum (Limited Media only), 50% Serum (Limited Media + Serum), and 50% Heat-inactivated (HI) Serum (Limited Media + HI-Serum). The heat-inactivated serum was created by incubating serum at 56^o^C for 30 minutes.

Before you begin to use this tutorial, you will need to install some packages in order to perform the analysis. The accompanying README file will detail which packages and what you need to do to install them into RStudio.

# Setting Up the Knit options for RMarkdown

Before we begin the analysis using R, we need to set up the knit options. Knitting is how Rstudio will print an output file. In this tutorial, we will knit to pdf, so when you hit the knit button, which is found at the top of the RMarkdown pane (which should be at the top of this window pane), Rstudio will run all of the different code chunks and save the results in a PDF. The following code chunk will set up some options for knitting. Run this code chunk by hitting the play button at the top right corner of the chunk (next to the cog wheel).

```{r setup, include=TRUE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

Let's breakdown what this code chunk does:

* knitr::opts_chunk$set -- this is the function that will allow us to set some options for how RStudio will knit our RMarkdown.
* warning = FALSE -- This tells Rstudio that we don't want to see any warning in the pdf when we knit.
* message = FALSE -- This will prevent warning messages when knitting.
* echo = FALSE -- This is not in the above code chunk, but worth mentioning. This condition will prevent RStudio from printing out the code chunks when you knit. This is a nice option to make your pdf output a little more professional.

# Loading the Appropriate Libraries
This code chunk will load the necessary libraries need for our analysis. These libraries should already be installed, but if not, please see the README file on how to do it.

Every time you open a project in RStudio, you will need to run your library code chunk, or a lot of your code chunks will just return an error instead of the results you want. Go ahead and run this code chunk.
```{r load libraries}
library(dplyr)
library(ggplot2)
library(tinytex)
library(tidyverse)
library(readxl)
library(viridis)
library(ggpubr)
library(knitr)
library(kableExtra)
```

# Preparing Data for Analysis

## Importing Data from Excel

RStudio is a great tool for analyzing your data, but it is very tedious to input that data into a usable format in RStudio. We opted to using Excel to organize our data and import it into RStudio. Run the following code chunk and select the tutorial Excel file to import the data to RStudio.

```{r read file}
# raw_data <- read_excel(file.choose(), sheet = "Sheet1")
raw_data <- read_excel("C:/Users/kopot/Documents/SGA-Tutorial/SGA_Example_DataSet.xlsx", 
                       sheet = "Sheet1")
raw_data
```

* raw_data -- this is a name for a variable we chose to store our EXcel data. The "<-" says to store everything to the left of our variable name into that variable name. You can see what is in that variable by having a line that has just the variable name.
* read_excel <- This function is part of the readxl library and will read_excel in a RStudio friendly format.
    + file.choose() -- This will prompt a window that will let you choose an excel file for RStudio to load.
    + sheet -- This will tell the read_excel function which sheet in Excel contains the data you want to import into RStudio. The default is "Sheet1", so we'll leave it like this for now.

## Replacing Special Characters in Column Names

While RStudio is great for analyzing data, we have to format our data to use it in RStudio. RStudio does not like having special characters in the column names and will not perform analysis. First we will identify and remove special characters from the column names in our data set.

This code chunk will store our data set into a new variable. Whenever you are formatting your data, it is recommended to store your data into a new variable and use that to perform your formatting, so that you can go back if you make a mistake. Run the following code chunk to create a new data set that we will use.

```{r, New datset}
raw_data_colnames <- raw_data
```

The following code chunk identifies the special characters by their unicode and replaces them with specified text. 

```{r, Replacing Special Characters}
delta_replace <- gsub("\u0394", "del", colnames(raw_data_colnames))
colnames(raw_data_colnames) <- delta_replace
options(dplyr.width = Inf)
raw_data_colnames
```

* data_replace <- list of new column names
* gsub <- creates a list with the special character replaced by the given text
    + "\u0394" -- unicode for the special character
    + "del" -- text that will be replacing the character
    + colnames() -- the text specifies which dataset the code is changing
* options <- changes with options for knitting the table
    + dplyr.width = Inf -- changes the width of the table to infinity so that the whole table fits on one page
* raw_data_colnames <- this just displays the changed dataset


## Averaging Blank Measurements for Removing Background Noise

```{r, second New dataset}
raw_data_blank_mean <- raw_data_colnames
```

```{r, Averaging Blanks}
raw_data_blank_mean <- raw_data_colnames %>%
  select(contains("Blank")) %>%
  colMeans(na.rm = TRUE) %>%
  round(3)
```

* select() <- allows you to pick which columns to use in the code. You can also remove columns by typing a "-" symbol before the column name.
    + contains("") -- this looks at the titles of the columns and selects the ones that have the inputted value/text within the quotations
* colMeans() <- this calculates the means for each column
    + na.rm = TRUE -- this tells it to ignore the NA values
* round() <- this tells it to what decimal point to round to

## Removing Blank Measurement from Table

```{r clean data}
raw_data_clean <- raw_data_colnames %>%
  select(-`0% (Blank)`, -`50% (Blank)`, -`HI-50% (Blank)`, -`Time`)
```

## Removing Background Noise



```{r for loop}
for (a in 1:ncol(raw_data_clean)) {
 if (grepl(" 0%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[1])
 }
 if (grepl(" 50%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[2])
 }
 if (grepl("-50%", colnames(raw_data_clean)[a])) {
   raw_data_clean[ , a] <- raw_data_clean[ , a] - 
     as.numeric(raw_data_blank_mean[3])
 }
}
```

* for(){} <- this codes a conditional statement where for the values specified in the parenthesis it will loop through all the values, running the code specified within the curly brackets. This will stop when it reaches the end of the values
* if(){} <- this codes a conditional statement of if whatever in the parenthesis is true, then run the code in the curly brackets. If false, then do nothing
    + grepl() <- this looks for a specific inputted value and returns either TRUE or FALSE
    + a --
    + as.numeric() <- this tells it to turn the inputted values into numbers if they are not saved as such


``` {r replace}
raw_data_clean_t <- raw_data_clean

delta_replace <- gsub("del", "\u0394", colnames(raw_data_clean_t))

colnames(raw_data_clean_t) <- delta_replace

options(dplyr.width = Inf)
kable(raw_data_clean_t, caption = "Serum Growth Assay for eOP16", "latex", 
      booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down", "hold_position"))
```

* kable() <- displays a dataset in a table
    + caption = "" -- text which appears above the table?
    + booktabs = T -- changes the way LaTex formats and displays the table
    + kable_styling() -- allows for customization of the displayed table
    + latex_options = "" -- customizes the colors and structure of the table

# Transforming the Data

```{r time}
trans_data <- stack(raw_data_clean)
time_data <- raw_data_colnames %>%
  select(`Time`)
length <- length(raw_data_clean)
time_data <- cbind(rep(time_data$Time, as.numeric(length)))
trans_data <- cbind(trans_data, time_data)
colnames(trans_data) <- c("OD", "Sample", "Time")
```

* stack() <- stacks multiple columns into one column
* length() <- the amount of columns in the dataset
* cbind() <- combines data by columns
    + rep() -- the data that will be repeated a set number of times

# Graphing Cleaned Data

```{r plots}
od_600 = expression(paste(OD[600]))
zero_plot <- trans_data %>%
  filter(grepl(" 0%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "0% Serum", y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

fifty_plot <- trans_data %>%
  filter(grepl(" 50%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "50% Serum",  y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

hi_plot <- trans_data %>%
  filter(grepl("HI-50%", Sample)) %>%
  ggplot(aes(x = Time, color = Sample, y = OD))+
  geom_point(size = 1.5)+
  geom_line()+
  labs(title = "HI-50% Serum", y = od_600)+
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_blank())+
  scale_colour_manual(values = c("#c51b8a","#d95f0e","#2c7fb8"), 
                      labels = c("WT", "-1\u0394", "-2\u0394"))+
  xlim(0,4)+
  ylim(-0.5,1)

figure_1 <- ggarrange(zero_plot, fifty_plot, hi_plot,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2, common.legend = TRUE,legend="bottom")
annotate_figure(figure_1, top = text_grob("Serum Growth Assay for eOP16", 
               color = "black", face = "bold", size = 14))
```

* expression() <- creates an object
    + paste() <- chains together vectors after converting them to characters
* filter() <- this selects which columns to analyze by given parameters
* ggplot() <- allows the data to be displayed within a plot
    + aes() -- this is what is used to choose which variables are displayed on different portions of the graph
    + y = "" -- variable displayed on the y-axis
    + x = "" -- variable displayed on the x-axis
    + color = "" -- variable displayed through the colors
* geom_point() -- this selects a scatterplot as the specific plot
* goem_line() -- this creates a line between point on the scatterplot
* labs() -- this labels various potions of the plot
    + title = "" -- labels the title
    + y = "" -- labels the y-axis
* theme() -- customizes non-data portion of the plot
    + plot.title = "" -- the title of the plot
    + element_text() -- tells it to look at the variable title and use that?
    + hjust = 0.5 -- changes the size of the 
    + legend.title = "" -- alters the legend title
    + element_blank() -- tells it to exclude the legend title
* scale_colour_manual() -- customizes the color types and scale of the colors
    + values = "" -- selects the colors based on their hex number
    + labels = "" -- labels the legend
* xlim() -- x axis limits
* ylim() -- y axis limits
* ggarrange() <- allows for multiple plots to be displayed at once together
    + labels = "" -- labels the various plots
    + ncol = "" -- how many plots are side by side
    + nrow = "" -- how many plots are up and down
    + common.legend = TRUE -- this allows for there to be a common legend, or if it was false than the graphs would have seperate legends
    + legend = "" -- location of the legend in relation to the placement of the graph
* annotate_figure() <- customizes the plot figure that was created
    + top = "" -- placement of the figure title
    + text_grob() -- the text that will show up as the figure title
    + color = "" -- changes the color of the text
    + face = "" -- changes the font (i.e. italics, bold, etc.)
    + size = "" -- size of text

